Obiettivo sintetico:
Implementa un sistema di autenticazione **locale** (email + password) affiancato alla login Replit esistente. Gli utenti devono potersi **registrare** fornendo: email, password (con conferma), nome e cognome. Mantieni il pulsante "Accedi" attuale in alto nella landing ma nel dive con titolo "pronto a iniziare?" dove ora esiste un button "accedi" sostituisci quel button con un link/pulsante che porta alla nuova form di registrazione (`/register`). La registrazione deve creare un utente nel DB con password hashata in modo sicuro.

**AGGIUNTA IMPORTANTE:** Il sistema deve includere il flusso **"Password dimenticata"** (richiesta reset + reset tramite link) implementato in modo sicuro come descritto sotto.

Fasi: (l’agent deve *auto-detect* lo stack e scegliere l’implementazione corretta; vedi dettagli per Node/Express e per stack Python sotto)
1. Detect stack del progetto (file package.json, requirements.txt, pyproject, vercel/next config, ecc).
2. In caso di psw dimenticata 
         - Normalizza email; cerca user. **Indipendentemente dal fatto che l'utente esista, ritorna sempre lo stesso messaggio generico** in italiano: "Se esiste un account associato all'email, riceverai un'email con le istruzioni per reimpostare la password."
         - Se l'utente esiste: genera un token sicuro (es. `crypto.randomBytes(32)`), codifica in base64url, calcola hash (es. SHA-256) del token e salva in tabella `password_reset_tokens` con: id, user_id, token_hash, expires_at (default 1 ora), used=false, created_at, request_ip (opzionale).
         - Invia email contenente link di reset HTTPS: `${APP_URL}/reset-password?token=<token>&email=<email>` (non includere dati sensibili). Usa template italiano. Se SMTP non configurato, registra il link nel log per testing (ma non nel DB in chiaro).
         - Rate-limit endpoint per IP e per account (es. max 3 richieste / ora per account; 10 richieste / ora per IP) e supporta CAPTCHA opzionale.
3.password
       - Validazioni: password min 8, password === passwordConfirm.
         - Calcola hash del token fornito e cerca record in `password_reset_tokens` per user/email con matching token_hash.
         - Verifica che il token esista, non sia scaduto (`expires_at`), e `used === false`.
         - Se tutto OK: aggiorna `users.password_hash` con nuovo bcrypt hash, marca il token come `used=true` (o elimina il record), registra evento di sicurezza, invalida tutte le sessioni attive dell'utente (es. incrementa `tokenVersion` o pulisci store delle sessioni) e invia email di notifica "La password del tuo account è stata modificata" (se SMTP attivo).
         - Rispondere con messaggio generico di successo e redirect a `/login`.
       - Se token non valido o scaduto: rispondere con errore generico (non dire "token inesistente") e chiedere di richiedere nuovamente reset.
     
4. Database / schema:
   - Tabella `users`: id, email (unique), password_hash, first_name, last_name, created_at, updated_at, email_verified (false), token_version (int default 0), last_login.
   - Tabella `password_reset_tokens`: id, user_id, token_hash, expires_at, used (bool), created_at, request_ip.

5. Frontend:
   - Pagina `/register` con campi: email, password, conferma password, nome, cognome.
   - Pagina `/login` mantiene opzione Replit Auth  aggiunge link "Password dimenticata?" che porta a `/forgot-password` e aggiunge campi email e password per permettere agli utenti di accedere
   - Pagina `/forgot-password`: form che invia `POST /api/auth/forgot-password` con solo email. Mostra messaggio generico dopo invio.
   - Pagina `/reset-password`: legge `token` ed `email` da query string, mostra form per impostare nuova password + conferma; 
   - Dopo reset redirect a `/login` con messaggio di successo.
   - Mantieni testo e messaggi in italiano.
6. Sicurezza (dettagli obbligatori):
   - Hash password con bcrypt (BCRYPT_ROUNDS >= 12).
   - Reset token: `RESET_TOKEN_BYTES` (default 32), salva solo hash (es. SHA-256) del token, token expiry `RESET_TOKEN_EXPIRY` (default 3600 secondi).
   - Token monouso: marca `used=true` dopo utilizzo.
   - Rate-limit gli endpoint critici (`/api/auth/login`, `/api/auth/forgot-password`, `/api/auth/reset-password`).
   - Evita user enumeration: risposte generiche su `/forgot-password`.
   - Invalida sessioni attive dopo il reset (incrementa `token_version` o pulisci session store).
   - Fornisci logging di eventi di sicurezza (richiesta reset, reset valido, reset fallito).
   - Richiedi HTTPS nelle URL inviate via email e documentalo (Replit usa HTTPS di default).
   - Email di notifica post-change: invia sempre email di avviso del cambio password.
7. Variabili d’ambiente (aggiungi README / comment in codice):
   - `SESSION_SECRET` o `JWT_SECRET`
   - `BCRYPT_ROUNDS` (default 12)
   - `RESET_TOKEN_EXPIRY` (default 3600)
   - `RESET_TOKEN_BYTES` (default 32)
   - SMTP vars (`SMTP_HOST`, `SMTP_PORT`, `SMTP_USER`, `SMTP_PASS`, `FROM_EMAIL`)
   - `APP_URL` (usata per costruire il link di reset)
8. UX e messaggi (in italiano):
   - Messaggi chiari per validazione (es. "Email non valida", "La password deve essere di almeno 8 caratteri", "Le password non coincidono").
   - Messaggi generici per sicurezza su forgot-password (es. "Se esiste un account associato all'email, riceverai un'email con le istruzioni").
   - Messaggio di avviso via email a reset effettuato.
9. Logging & testing:
   - Log eventi rilevanti; non loggare password o token in chiaro.
   - Fornisci HOW-TO per testare: come generare reset, dove trovare link in log se SMTP non configurato, come verificare che token sia monouso.
10. Commit & report:
   - Commit chiari (es. "feat(auth): add forgot-password flow with secure reset tokens"), lista file modificati/aggiunti e istruzioni per test manuale nell’output dell’agent.
   - Documenta come impostare Replit Secrets per le env vars citate.
11. Comportamento in caso di ambiguità
   - Se stack non riconosciuto, crea Node/Express + SQLite e integra front-end esistente.
12. Output finale richiesto dall’agent (deve restituire QUI):
   - Lista dei file modificati / aggiunti.
   - I comandi per impostare le secrets su Replit.
   - I passi per testare registrazione, login, forgot-password e reset (es. 1) apri /forgot-password 2) invia email 3) recupera link da log o email 4) reset password 5) verifica logout di sessioni).
   - Messaggi di commit e branch/PR creati (se applicabile).

### Requisiti di acceptance (checkpoint che l’agent DEVE soddisfare)
- [ ] Esiste `/register` funzionante.
- [ ] La POST `/api/auth/register` crea un utente con password hashata.
- [ ] È possibile fare login con la API e ottenere sessione/cookie HttpOnly.
- [ ] Esiste `/forgot-password` che invia richiesta a `/api/auth/forgot-password`. La risposta è generica (non rivela esistenza account).
- [ ] Viene creato un token di reset sicuro, salvato solo come hash, con scadenza e flag `used`.
- [ ] Esiste `/reset-password` che accetta token e consente di impostare nuova password tramite `POST /api/auth/reset-password`.
- [ ] Il token è monouso e scade dopo `RESET_TOKEN_EXPIRY` secondi.
- [ ] Dopo reset tutte le sessioni utente attive sono invalidate.
- [ ] Rate-limiting per endpoint critici e (opzionale) CAPTCHA su `/forgot-password`.
- [ ] Env vars documentate e istruzioni per Replit Secrets incluse.
- [ ] Commit include lista file e istruzioni di testing.



### Comportamento extra di sicurezza che l’agent deve applicare automaticamente
- Non loggare token o password in chiaro.
- Impostare limite di richieste sul `forgot-password`.
- Mostrare link per debug solo nei log se SMTP non configurato (documenta questo comportamento).
- Invia email di notifica dopo cambio password.